package main

import (
	"context"
	"fmt"
	"log"
	"os"
	"strconv"

	"cloud.google.com/go/datastore"
	"goread2/internal/config"
	"goread2/internal/database"
	"goread2/internal/services"
)

func main() {
	// SECURITY: Require admin token for sensitive operations
	adminToken := os.Getenv("ADMIN_TOKEN")
	if adminToken == "" {
		fmt.Println("ERROR: ADMIN_TOKEN environment variable must be set")
		fmt.Println("This token must be generated and stored in the database by an existing admin.")
		fmt.Println("Use the 'create-token' command if you are the first admin.")
		os.Exit(1)
	}

	command := ""
	if len(os.Args) > 1 {
		command = os.Args[1]
	}

	// SECURITY: Validate admin token format (64 hex characters = 32 bytes)
	// Exception: 'create-token' command allows any token for bootstrap
	if command != "create-token" && len(adminToken) != 64 {
		fmt.Println("ERROR: ADMIN_TOKEN must be exactly 64 characters (32 bytes as hex)")
		fmt.Println("Valid tokens are generated by the 'create-token' command.")
		fmt.Println("For initial setup, use any value with 'create-token' command.")
		os.Exit(1)
	}

	if len(os.Args) < 2 {
		fmt.Println("Usage: go run cmd/admin/main.go <command> [args]")
		fmt.Println("Commands:")
		fmt.Println("  create-token <description>    - Generate new admin token (bootstrap only)")
		fmt.Println("  list-tokens                   - List all admin tokens")
		fmt.Println("  revoke-token <token-id>       - Revoke an admin token")
		fmt.Println("  list-users                    - List all users")
		fmt.Println("  set-admin <email> <true/false> - Set admin status for user")
		if config.IsSubscriptionEnabled() {
			fmt.Println("  grant-months <email> <months>  - Grant free months to user")
		}
		fmt.Println("  user-info <email>             - Show user information")
		fmt.Println("  fix-subscription <email>      - Fix subscription status from Stripe")
		fmt.Println("  debug-users                   - Debug user lookup issues")
		fmt.Println("")
		fmt.Println("SECURITY NOTES:")
		fmt.Println("  - Admin tokens are securely stored in the database as hashes")
		fmt.Println("  - Use 'create-token' for initial bootstrap (no validation)")
		fmt.Println("  - All other commands require valid database token authentication")
		fmt.Println("  - Tokens can be revoked and are tracked with usage timestamps")
		os.Exit(1)
	}

	// command is already set above for validation

	// Initialize database and services first
	db, err := database.InitDB()
	if err != nil {
		log.Fatal("Failed to initialize database:", err)
	}
	defer func() { _ = db.Close() }()

	subscriptionService := services.NewSubscriptionService(db)

	// SECURITY: Verify admin token against database for most operations
	// Only 'create-token' bypasses validation for bootstrap scenarios
	if command != "create-token" {
		valid, err := subscriptionService.ValidateAdminToken(adminToken)
		if err != nil {
			fmt.Printf("ERROR: Failed to validate admin token: %v\n", err)
			os.Exit(1)
		}
		if !valid {
			fmt.Println("ERROR: Invalid ADMIN_TOKEN - token not found in database or inactive")
			fmt.Println("Generate a new token with 'create-token' or contact your administrator.")
			os.Exit(1)
		}
	}

	switch command {
	case "create-token":
		if len(os.Args) != 3 {
			fmt.Println("Usage: go run cmd/admin/main.go create-token <description>")
			fmt.Println("Example: go run cmd/admin/main.go create-token \"Initial admin setup\"")
			os.Exit(1)
		}
		description := os.Args[2]
		createAdminToken(subscriptionService, description)

	case "list-tokens":
		listAdminTokens(subscriptionService)

	case "revoke-token":
		if len(os.Args) != 3 {
			fmt.Println("Usage: go run cmd/admin/main.go revoke-token <token-id>")
			os.Exit(1)
		}
		tokenID, err := strconv.Atoi(os.Args[2])
		if err != nil {
			log.Fatal("Invalid token ID:", err)
		}
		revokeAdminToken(subscriptionService, tokenID)

	case "list-users":
		listUsers(db, subscriptionService)

	case "set-admin":
		if len(os.Args) != 4 {
			fmt.Println("Usage: go run cmd/admin/main.go set-admin <email> <true/false>")
			os.Exit(1)
		}
		email := os.Args[2]
		isAdminStr := os.Args[3]
		isAdmin, err := strconv.ParseBool(isAdminStr)
		if err != nil {
			log.Fatal("Invalid admin status, use 'true' or 'false':", err)
		}
		setAdminStatus(subscriptionService, email, isAdmin)

	case "grant-months":
		if !config.IsSubscriptionEnabled() {
			fmt.Println("Error: Subscription system is disabled. Cannot grant free months.")
			fmt.Println("Set SUBSCRIPTION_ENABLED=true to enable subscription features.")
			os.Exit(1)
		}
		if len(os.Args) != 4 {
			fmt.Println("Usage: go run cmd/admin/main.go grant-months <email> <months>")
			os.Exit(1)
		}
		email := os.Args[2]
		monthsStr := os.Args[3]
		months, err := strconv.Atoi(monthsStr)
		if err != nil {
			log.Fatal("Invalid months value:", err)
		}
		grantFreeMonths(subscriptionService, email, months)

	case "user-info":
		if len(os.Args) != 3 {
			fmt.Println("Usage: go run cmd/admin/main.go user-info <email>")
			os.Exit(1)
		}
		email := os.Args[2]
		showUserInfo(subscriptionService, email)

	case "fix-subscription":
		if len(os.Args) != 3 {
			fmt.Println("Usage: go run cmd/admin/main.go fix-subscription <email>")
			os.Exit(1)
		}
		email := os.Args[2]
		fixSubscriptionStatus(subscriptionService, email)

	case "set-subscription-id":
		if len(os.Args) != 4 {
			fmt.Println("Usage: go run cmd/admin/main.go set-subscription-id <email> <subscription-id>")
			os.Exit(1)
		}
		email := os.Args[2]
		subscriptionID := os.Args[3]
		setSubscriptionID(subscriptionService, email, subscriptionID)

	default:
		fmt.Printf("Unknown command: %s\n", command)
		os.Exit(1)
	}
}

func listUsers(db database.Database, subscriptionService *services.SubscriptionService) {
	// For SQLite implementation, we can access the underlying DB
	if sqliteDB, ok := db.(*database.DB); ok {
		// Simple query to list all users
		query := `SELECT id, email, name, subscription_status, 
				  COALESCE(is_admin, 0), COALESCE(free_months_remaining, 0),
				  created_at FROM users ORDER BY id`

		rows, err := sqliteDB.Query(query)
		if err != nil {
			log.Fatal("Failed to query users:", err)
		}
		defer func() { _ = rows.Close() }()

		fmt.Printf("\n%-4s %-35s %-25s %-12s %-6s %-6s %-12s\n",
			"ID", "Email", "Name", "Status", "Admin", "Free", "Joined")
		fmt.Printf("%-4s %-35s %-25s %-12s %-6s %-6s %-12s\n",
			"----", "-----------------------------------", "-------------------------", "------------", "------", "------", "------------")

		for rows.Next() {
			var id int
			var email, name, status string
			var isAdmin bool
			var freeMonths int
			var createdAt string

			err := rows.Scan(&id, &email, &name, &status, &isAdmin, &freeMonths, &createdAt)
			if err != nil {
				log.Fatal("Failed to scan user:", err)
			}

			adminStr := "No"
			if isAdmin {
				adminStr = "Yes"
			}

			fmt.Printf("%-4d %-35s %-25s %-12s %-6s %-6d %-12s\n",
				id, truncate(email, 34), truncate(name, 24), status, adminStr, freeMonths, createdAt[:10])
		}
		fmt.Println()
	} else if datastoreDB, ok := db.(*database.DatastoreDB); ok {
		// Datastore implementation
		ctx := context.Background()
		
		fmt.Println("Using Google Cloud Datastore - querying users...")
		
		query := datastore.NewQuery("User").Order("created_at")
		var users []*database.UserEntity
		keys, err := datastoreDB.GetClient().GetAll(ctx, query, &users)
		if err != nil {
			fmt.Printf("Error querying users from datastore: %v\n", err)
			fmt.Println("Trying to get specific user by email instead...")
			
			// Fallback: try to get the specific user we know exists
			user, err := subscriptionService.GetUserByEmail("jeffrey@jeffreypratt.org")
			if err != nil {
				fmt.Printf("Cannot find jeffrey@jeffreypratt.org either: %v\n", err)
				log.Fatal("Failed to query users and fallback failed")
			}
			
			fmt.Printf("\nFound user via direct lookup:\n")
			fmt.Printf("ID: %d, Email: %s, Name: %s, Status: %s\n", 
				user.ID, user.Email, user.Name, user.SubscriptionStatus)
			return
		}

		fmt.Printf("Found %d users in datastore\n", len(users))

		fmt.Printf("\n%-4s %-35s %-25s %-12s %-6s %-6s %-12s\n",
			"ID", "Email", "Name", "Status", "Admin", "Free", "Joined")
		fmt.Printf("%-4s %-35s %-25s %-12s %-6s %-6s %-12s\n",
			"----", "-----------------------------------", "-------------------------", "------------", "------", "------", "------------")

		for i, user := range users {
			adminStr := "No"
			if user.IsAdmin {
				adminStr = "Yes"
			}

			status := user.SubscriptionStatus
			if status == "" {
				status = "trial"
			}

			fmt.Printf("%-4d %-35s %-25s %-12s %-6s %-6d %-12s\n",
				int(keys[i].ID),
				truncate(user.Email, 34),
				truncate(user.Name, 24),
				status,
				adminStr,
				user.FreeMonthsRemaining,
				user.CreatedAt.Format("2006-01-02"))
		}
		fmt.Println()
	} else {
		log.Fatal("List users command only supports SQLite and Datastore databases")
	}
}

func setAdminStatus(subscriptionService *services.SubscriptionService, email string, isAdmin bool) {
	// Find user by email
	user, err := subscriptionService.GetUserByEmail(email)
	if err != nil {
		log.Fatal("User not found:", err)
	}

	// Set admin status
	err = subscriptionService.SetUserAdmin(user.ID, isAdmin)
	if err != nil {
		log.Fatal("Failed to set admin status:", err)
	}

	status := "removed from"
	if isAdmin {
		status = "granted"
	}

	fmt.Printf("✅ Admin access %s for user: %s (%s)\n", status, user.Name, user.Email)
}

func grantFreeMonths(subscriptionService *services.SubscriptionService, email string, months int) {
	// Find user by email
	user, err := subscriptionService.GetUserByEmail(email)
	if err != nil {
		log.Fatal("User not found:", err)
	}

	// Grant free months
	err = subscriptionService.GrantFreeMonths(user.ID, months)
	if err != nil {
		log.Fatal("Failed to grant free months:", err)
	}

	fmt.Printf("✅ Granted %d free months to user: %s (%s)\n", months, user.Name, user.Email)
	fmt.Printf("   Total free months: %d\n", user.FreeMonthsRemaining+months)
}

func showUserInfo(subscriptionService *services.SubscriptionService, email string) {
	// Find user by email
	user, err := subscriptionService.GetUserByEmail(email)
	if err != nil {
		log.Fatal("User not found:", err)
	}

	// Get subscription info
	subscriptionInfo, err := subscriptionService.GetUserSubscriptionInfo(user.ID)
	if err != nil {
		log.Fatal("Failed to get subscription info:", err)
	}

	fmt.Printf("\n┌─────────────────────────────────────────────────────────────────┐\n")
	fmt.Printf("│                         User Information                        │\n")
	fmt.Printf("├─────────────────────────────────────────────────────────────────┤\n")
	fmt.Printf("│ %-20s │ %-42s │\n", "ID:", fmt.Sprintf("%d", user.ID))
	fmt.Printf("│ %-20s │ %-42s │\n", "Name:", user.Name)
	fmt.Printf("│ %-20s │ %-42s │\n", "Email:", user.Email)
	fmt.Printf("│ %-20s │ %-42s │\n", "Joined:", user.CreatedAt.Format("2006-01-02 15:04:05"))
	fmt.Printf("│ %-20s │ %-42s │\n", "Google ID:", user.GoogleID)
	fmt.Printf("├─────────────────────────────────────────────────────────────────┤\n")
	fmt.Printf("│                      System Configuration                       │\n")
	fmt.Printf("├─────────────────────────────────────────────────────────────────┤\n")
	fmt.Printf("│ %-20s │ %-42s │\n", "Subscription System:", map[bool]string{true: "Enabled", false: "Disabled"}[config.IsSubscriptionEnabled()])
	fmt.Printf("├─────────────────────────────────────────────────────────────────┤\n")
	fmt.Printf("│                      Subscription Details                       │\n")
	fmt.Printf("├─────────────────────────────────────────────────────────────────┤\n")
	fmt.Printf("│ %-20s │ %-42s │\n", "Status:", subscriptionInfo.Status)
	fmt.Printf("│ %-20s │ %-42s │\n", "Is Admin:", map[bool]string{true: "Yes", false: "No"}[user.IsAdmin])

	if config.IsSubscriptionEnabled() {
		fmt.Printf("│ %-20s │ %-42s │\n", "Free Months:", fmt.Sprintf("%d", user.FreeMonthsRemaining))
	}

	fmt.Printf("│ %-20s │ %-42s │\n", "Current Feeds:", fmt.Sprintf("%d", subscriptionInfo.CurrentFeeds))

	if subscriptionInfo.FeedLimit == -1 {
		fmt.Printf("│ %-20s │ %-42s │\n", "Feed Limit:", "Unlimited")
	} else {
		fmt.Printf("│ %-20s │ %-42s │\n", "Feed Limit:", fmt.Sprintf("%d", subscriptionInfo.FeedLimit))
	}

	if subscriptionInfo.Status == "trial" {
		fmt.Printf("│ %-20s │ %-42s │\n", "Trial Ends:", user.TrialEndsAt.Format("2006-01-02 15:04:05"))
		fmt.Printf("│ %-20s │ %-42s │\n", "Days Remaining:", fmt.Sprintf("%d", subscriptionInfo.TrialDaysRemaining))
	}

	if user.SubscriptionID != "" {
		fmt.Printf("│ %-20s │ %-42s │\n", "Stripe Subscription:", user.SubscriptionID)
	}

	if !user.LastPaymentDate.IsZero() {
		fmt.Printf("│ %-20s │ %-42s │\n", "Last Payment:", user.LastPaymentDate.Format("2006-01-02 15:04:05"))
	}

	fmt.Printf("└─────────────────────────────────────────────────────────────────┘\n\n")
}

func fixSubscriptionStatus(subscriptionService *services.SubscriptionService, email string) {
	// Find user by email
	user, err := subscriptionService.GetUserByEmail(email)
	if err != nil {
		log.Fatal("User not found:", err)
	}

	fmt.Printf("Checking subscription status for user: %s (%s)\n", user.Name, user.Email)
	fmt.Printf("Current database status: %s\n", user.SubscriptionStatus)

	if user.SubscriptionID == "" {
		fmt.Println("No Stripe subscription ID found - nothing to fix.")
		return
	}

	fmt.Printf("Found Stripe subscription ID: %s\n", user.SubscriptionID)
	fmt.Println("Fetching current status from Stripe and updating database...")

	// Create payment service to handle subscription update
	paymentService := services.NewPaymentService(subscriptionService.GetDB(), subscriptionService)
	
	// This will fetch from Stripe and update the database
	err = paymentService.HandleSubscriptionUpdate(user.SubscriptionID)
	if err != nil {
		log.Fatal("Failed to update subscription from Stripe:", err)
	}

	// Get updated user info
	updatedUser, err := subscriptionService.GetUserByEmail(email)
	if err != nil {
		log.Fatal("Failed to get updated user info:", err)
	}

	fmt.Printf("✅ Subscription status updated successfully!\n")
	fmt.Printf("   Previous status: %s\n", user.SubscriptionStatus)
	fmt.Printf("   Current status:  %s\n", updatedUser.SubscriptionStatus)
	
	if !updatedUser.LastPaymentDate.IsZero() {
		fmt.Printf("   Last payment:    %s\n", updatedUser.LastPaymentDate.Format("2006-01-02 15:04:05"))
	}
}

func setSubscriptionID(subscriptionService *services.SubscriptionService, email, subscriptionID string) {
	// Find user by email
	user, err := subscriptionService.GetUserByEmail(email)
	if err != nil {
		log.Fatal("User not found:", err)
	}

	fmt.Printf("Updating subscription ID for user: %s (%s)\n", user.Name, user.Email)
	fmt.Printf("Current subscription ID: %s\n", user.SubscriptionID)
	fmt.Printf("New subscription ID: %s\n", subscriptionID)

	// Update subscription ID directly in database
	err = subscriptionService.UpdateUserSubscription(user.ID, user.SubscriptionStatus, subscriptionID, user.LastPaymentDate)
	if err != nil {
		log.Fatal("Failed to update subscription ID:", err)
	}

	fmt.Printf("✅ Subscription ID updated successfully!\n")
	
	// Now sync the status from Stripe using the new subscription ID
	fmt.Println("Now syncing status from Stripe with new subscription ID...")
	
	paymentService := services.NewPaymentService(subscriptionService.GetDB(), subscriptionService)
	err = paymentService.HandleSubscriptionUpdate(subscriptionID)
	if err != nil {
		fmt.Printf("Warning: Failed to sync status from Stripe: %v\n", err)
	} else {
		// Get updated user info
		updatedUser, err := subscriptionService.GetUserByEmail(email)
		if err != nil {
			fmt.Printf("Warning: Failed to get updated user info: %v\n", err)
		} else {
			fmt.Printf("✅ Status synced from Stripe: %s\n", updatedUser.SubscriptionStatus)
		}
	}
}

func truncate(s string, max int) string {
	if len(s) <= max {
		return s
	}
	return s[:max-3] + "..."
}

// createAdminToken generates a new admin token and stores it in the database
func createAdminToken(subscriptionService *services.SubscriptionService, description string) {
	// Check if any admin tokens already exist (for security warning)
	hasTokens, err := subscriptionService.HasAdminTokens()
	if err != nil {
		log.Fatal("Failed to check existing admin tokens:", err)
	}

	if hasTokens {
		fmt.Println("WARNING: Admin tokens already exist in the database.")
		fmt.Println("Only create new tokens if you're an authorized administrator.")
		fmt.Print("Continue? (y/N): ")

		var response string
		_, _ = fmt.Scanln(&response)
		if response != "y" && response != "Y" {
			fmt.Println("Token creation cancelled.")
			os.Exit(0)
		}
	} else {
		// SECURITY: For initial bootstrap, require at least one admin user exists
		if !hasAdminUsers(subscriptionService) {
			fmt.Println("ERROR: No admin users found in database.")
			fmt.Println("SECURITY: Initial token creation requires an existing admin user.")
			fmt.Println("")
			fmt.Println("Steps to resolve:")
			fmt.Println("1. Create your first user account through the web interface")
			fmt.Println("2. Manually set that user as admin in the database:")
			fmt.Println("   UPDATE users SET is_admin = 1 WHERE email = 'your@email.com'")
			fmt.Println("3. Then run this create-token command again")
			fmt.Println("")
			fmt.Println("This prevents unauthorized token creation by requiring database access.")
			os.Exit(1)
		}

		fmt.Println("Creating initial admin token...")
		fmt.Printf("Found admin users in database - proceeding with bootstrap.\n\n")
	}

	token, err := subscriptionService.GenerateAdminToken(description)
	if err != nil {
		log.Fatal("Failed to generate admin token:", err)
	}

	fmt.Printf("✅ Admin token created successfully!\n\n")
	fmt.Printf("Token: %s\n\n", token)
	fmt.Printf("IMPORTANT SECURITY NOTES:\n")
	fmt.Printf("1. This token will NEVER be displayed again\n")
	fmt.Printf("2. Store it securely (password manager, encrypted file)\n")
	fmt.Printf("3. Set it as ADMIN_TOKEN environment variable:\n")
	fmt.Printf("   export ADMIN_TOKEN=%s\n\n", token)
	fmt.Printf("4. This token provides full administrative access\n")
	fmt.Printf("5. Use 'revoke-token' to deactivate it if compromised\n")
}

// listAdminTokens displays all admin tokens (without the actual token values)
func listAdminTokens(subscriptionService *services.SubscriptionService) {
	tokens, err := subscriptionService.ListAdminTokens()
	if err != nil {
		log.Fatal("Failed to list admin tokens:", err)
	}

	if len(tokens) == 0 {
		fmt.Println("No admin tokens found.")
		fmt.Println("Create one with: go run cmd/admin/main.go create-token <description>")
		return
	}

	fmt.Printf("\n%-4s %-25s %-20s %-20s %-8s\n",
		"ID", "Description", "Created", "Last Used", "Status")
	fmt.Printf("%-4s %-25s %-20s %-20s %-8s\n",
		"----", "-------------------------", "--------------------", "--------------------", "--------")

	for _, token := range tokens {
		status := "Active"
		if !token.IsActive {
			status = "Revoked"
		}

		fmt.Printf("%-4d %-25s %-20s %-20s %-8s\n",
			token.ID,
			truncate(token.Description, 24),
			token.CreatedAt.Format("2006-01-02 15:04:05"),
			token.LastUsedAt.Format("2006-01-02 15:04:05"),
			status)
	}
	fmt.Println()
}

// revokeAdminToken deactivates an admin token
func revokeAdminToken(subscriptionService *services.SubscriptionService, tokenID int) {
	err := subscriptionService.RevokeAdminToken(tokenID)
	if err != nil {
		log.Fatal("Failed to revoke admin token:", err)
	}

	fmt.Printf("✅ Admin token %d has been revoked successfully.\n", tokenID)
	fmt.Printf("The token is now inactive and cannot be used for authentication.\n")
}

// hasAdminUsers checks if any admin users exist in the database
func hasAdminUsers(subscriptionService *services.SubscriptionService) bool {
	// We need to check the database directly since SubscriptionService doesn't have this method
	// This is a security check to prevent unauthorized bootstrap

	db, err := database.InitDB()
	if err != nil {
		fmt.Printf("ERROR: Cannot connect to database: %v\n", err)
		return false
	}
	defer func() { _ = db.Close() }()

	// Check if database supports direct queries (SQLite implementation)
	if sqliteDB, ok := db.(*database.DB); ok {
		var count int
		query := `SELECT COUNT(*) FROM users WHERE is_admin = 1`
		err := sqliteDB.QueryRow(query).Scan(&count)
		if err != nil {
			fmt.Printf("ERROR: Failed to check admin users: %v\n", err)
			return false
		}
		
		return count > 0
	} else if datastoreDB, ok := db.(*database.DatastoreDB); ok {
		ctx := context.Background()

		query := datastore.NewQuery("User").
			FilterField("is_admin", "=", true).
			Limit(1)

		count, err := datastoreDB.GetClient().Count(ctx, query)
		if err != nil {
			fmt.Printf("ERROR: Failed to check admin users in datastore: %v\n", err)
			return false
		}
		return count > 0
	}

	// For unknown database types, assume no admin users for security
	fmt.Println("WARNING: Cannot verify admin users for this database type")
	return false
}
